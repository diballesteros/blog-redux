[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_26":27},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_18":19,"_20":21,"_22":23,"_24":25},"slug","how-to-migrate-zustand-local-storage-store-to-a-new-version","title","How to migrate Zustand local storage store to a new version","date","","description","How to improve SEO performance in a React app made by create-react-app with hosting configurations, metadata and integrations with various search engines","categories",[17],"react","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1651104528718/8HqaGn704.png","published",true,"readingTime",4,"content","\r\n### Introduction\r\n\r\n[Zustand](https://github.com/pmndrs/zustand) is a state-management solution for React apps. For anyone looking into a state manager that is low on boilerplate, very intuitive, and highly performant then I highly recommend using it.\r\n\r\n[I personally love it](https://relatablecode.com/developer-blog-nuzlocke-tracker-part-one-react-project-structure/).\r\n\r\nThis guide assumes you have some knowledge of the basics of Zustand.\r\n\r\n### Recapping LocalStorage Persistence\r\n\r\nBaked into the Zustand API is a middleware that allows persisting the store to local storage. An example of how this persistence would look like (example taken straight from the docs):\r\n\r\n```js\r\nexport const useStore = create(\r\n\tpersist(\r\n\t\t(set, get) => ({\r\n\t\t\tfishes: 0,\r\n\t\t\taddAFish: () => set({ fishes: get().fishes + 1 }),\r\n\t\t}),\r\n\t\t{\r\n\t\t\tname: 'food-storage', // unique name\r\n\t\t\tgetStorage: () => sessionStorage, // (optional) by default the 'localStorage' is used\r\n\t\t}\r\n\t)\r\n);\r\n```\r\n\r\nThe persist function wraps the store and automatically sets the values inside the local storage. The entirety of the store can be identified in the local storage by a **key** (name) and a **version** (number) that can also be set in the options. These options can be set in the persist function; it first receives the Zustand store and the second parameter is the aforementioned configuration object.\r\n\r\nAn issue that can pop up while creating a store that is persisted to local storage is that the structure of the store can change in an update to the application. This can cause inconsistencies between what the store expects and what is currently persisted.\r\n\r\nThis can, in the worst-case scenarios, cause errors that cause the application to crash. Yikes! In order to circumvent this problem, Zustand offers a migration function to transition a persisted store to the new **version**.\r\n\r\n### Scenario\r\n\r\nFor example, letâ€™s assume that our store currently looks something like this:\r\n\r\n```js\r\nconst AVAILABLE_FISHES = [\r\n\t{\r\n\t\tid: 1,\r\n\t\tname: 'Tuna',\r\n\t},\r\n\t{\r\n\t\tid: 2,\r\n\t\tname: 'Goldfish',\r\n\t},\r\n];\r\n\r\nexport const useStore = create(\r\n\tpersist(\r\n\t\t(set, get) => ({\r\n\t\t\tfishes: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 1,\r\n\t\t\t\t\tname: 'Tuna',\r\n\t\t\t\t},\r\n\t\t\t],\r\n\t\t\taddAFish: () => set({ fishes: get().fishes + 1 }),\r\n\t\t}),\r\n\t\t{\r\n\t\t\tname: 'food-storage', // unique name\r\n\t\t}\r\n\t)\r\n);\r\n```\r\n\r\nWhere our fishes key in the state should directly link up to a fish that exist in the **AVAILABLE_FISHES** constant.\r\n\r\nHowever, we have a problem, if the object structure of the fish we save ever changes then the corresponding object in the persisted store will not update. For example, if our **AVAILABLE_FISHES** constant now includes the color:\r\n\r\n```js\r\nconst FISHES = [\r\n\t{\r\n\t\tid: 1,\r\n\t\tname: 'Tuna',\r\n\t\tcolor: 'Blue',\r\n\t},\r\n\t{\r\n\t\tid: 2,\r\n\t\tname: 'Goldfish',\r\n\t\tcolor: 'Gold',\r\n\t},\r\n];\r\n```\r\n\r\nThe object saved in the fishes key no longer has all the information necessary. This can be easily remedied by migrating the store to a new structure and **version**.\r\n\r\n### Migration\r\n\r\nInitially, the **version** of the local storage is set to 0. This can be confirmed by opening up the dev tools and looking at the entry in the local storage.\r\n\r\n![Migration](https://cdn.hashnode.com/res/hashnode/image/upload/v1649267853559/idWWUk5Ej.png)\r\n\r\n![Migration](https://cdn.hashnode.com/res/hashnode/image/upload/v1649267854619/KY3fHJKgf.png)\r\n\r\nIn order for Zustand to detect a new store version, it must be set inside the persist configuration object.\r\n\r\n```js\r\nexport const useStore = create(\r\n\tpersist(\r\n\t\t(set, get) => ({\r\n\t\t\tfishes: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 1,\r\n\t\t\t\t\tname: 'Tuna',\r\n\t\t\t\t},\r\n\t\t\t],\r\n\t\t\taddAFish: () => set({ fishes: get().fishes + 1 }),\r\n\t\t}),\r\n\t\t{\r\n\t\t\tname: 'food-storage', // unique name\r\n\t\t\tversion: 1,\r\n\t\t\tmigrate: (persistedState) => {\r\n\t\t\t\t// Migrate store here...\r\n\t\t\t},\r\n\t\t}\r\n\t)\r\n);\r\n```\r\n\r\nOnce Zustand detects that version store 1 is superior to the persisted store 0 then it will try to migrate the store with the provided function.\r\n\r\nThis function receives the persisted local storage state as its parameter and expects a new store to be returned.\r\n\r\nReturning to our example we should link up our store exclusively to the ID and not the whole fish object.\r\n\r\n```js\r\nmigrate: (persistedState) => {\r\n\tconst oldFishes = persistedState.fishes;\r\n\tconst newFishes = oldFish.map((oldFish) => {\r\n\t\treturn oldFish.id;\r\n\t});\r\n\treturn newFishes;\r\n};\r\n```\r\n\r\nAnd with this the new object structure is correct and as soon as a user loads up the webpage it will automatically migrate its store to the new version.\r\n\r\nAny time a new change must be made it can easily be done by raising the version and updating the migrate function.\r\n","recommendations",[28,35,43,49],{"_7":29,"_9":30,"_11":12,"_13":31,"_15":32,"_18":34,"_20":21,"_22":23},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[33],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",{"_7":36,"_9":37,"_11":12,"_13":38,"_15":39,"_18":41,"_20":21,"_22":42},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[40,17],"testing","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png",3,{"_7":44,"_9":45,"_11":12,"_13":46,"_15":47,"_18":41,"_20":21,"_22":48},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[40,17],5,{"_7":50,"_9":51,"_11":12,"_13":52,"_15":53,"_18":41,"_20":21,"_22":23},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[40,17]]
