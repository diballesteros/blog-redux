[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_27":28},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_19":20,"_21":22,"_23":24,"_25":26},"slug","testing-a-react-application-integrating-msw-with-vitest","title","Testing a React Application Integrating MSW with Vitest","date","","description","Testing a React application. How to integrate MSW with vitest, a unit testing library.","categories",[17,18],"testing","react","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png","published",true,"readingTime",5,"content","\r\n### Introduction\r\n\r\nThe fifth part in my ongoing series on how to test a modern React application. This time I'll go over how to integrate MSW with [Vitest](https://vitest.dev/), our unit-test framework. Most applications have to fetch data from the backend server. In order to have full coverage, we should mock these requests. But, what is mocking?\r\n\r\n> Make a replica or imitation of something\r\n\r\n_Oxford Languages_\r\n\r\nThe idea is to create an imitation of a request coming in from the backend. This comes with its own set of advantages. We can directly manipulate what we want the _response_ to be to test for more scenarios. In the app we previously created we could test for fetching 0 posts, 100 posts, posts with no text, and so on and so forth.\r\n\r\nThe app in question:\r\n\r\n![barebones react app](https://cdn.hashnode.com/res/hashnode/image/upload/v1650898960866/P8SFjttzr.gif)\r\n\r\nThis is very powerful! We can test for common use cases or edge cases that the user may run into. And at the end of the day, the most important thing is confidence in our tests.\r\n\r\n### What is MSW?\r\n\r\n[MSW](https://mswjs.io/) is a mocking library that is extremely simple to use.\r\n\r\n> Mock by intercepting requests on the network level. Seamlessly reuse the same mock definition for testing, development, and debugging.\r\n\r\n_ mswjs.io_\r\n\r\nNormally, this would be the expected interaction:\r\n\r\n![Normal request fetching](https://cdn.hashnode.com/res/hashnode/image/upload/v1651579048789/_Bly2AQ8l.png)\r\n\r\nBut, with the added addition of MSW, we will add a new step.\r\n\r\n![Fetching with MSW](https://cdn.hashnode.com/res/hashnode/image/upload/v1651579243684/1hWQ6vwXM.png)\r\n\r\nAwesome! ðŸ˜Ž Let's get this set up with our application. For reference[here is the project](https://github.com/diballesteros/react-testing) we've been using up to this point.\r\n\r\n### Configuration files for MSW\r\n\r\nFirst, let's install our new library:\r\n\r\n```sh\r\nnpm install msw --save-dev\r\n\r\nyarn add msw --dev\r\n```\r\n\r\nIn our `src` directory let's create a `mocks` older where we'll keep the handlers for the requests. The MSW team refers to this as _mock definitions_. Inside the `mocks` folder create a `handlers.js`.\r\n\r\nHere we can export our handler functions. Since we're doing normal REST requests, let's import `rest` from MSW.\r\n\r\n```js\r\nimport { rest } from 'msw';\r\n```\r\n\r\nIn order for MSW to recognize the request, we must provide the exact _method_ and _path_ and export it from an array.\r\n\r\n```js\r\nexport const handlers = [\r\n\trest.get('https://jsonplaceholder.typicode.com/posts', null),\r\n];\r\n```\r\n\r\nHere we can replace `null` with what we actually want MSW to return to us. This is a function known as a _response resolver_. Returning the following:\r\n\r\n-   `req`, information about a matching request;\r\n\r\n-   `res`, a functional utility to create the mocked response;\r\n\r\n-   `ctx`, a group of functions that help to set a status code, headers, body, etc. of the mocked response.\r\n\r\nLet's return our own custom response for these posts.\r\n\r\n```js\r\nimport { rest } from 'msw';\r\n\r\nexport const handlers = [\r\n\trest.get('https://jsonplaceholder.typicode.com/posts', (req, res, ctx) => {\r\n\t\treturn res(\r\n\t\t\tctx.status(200),\r\n\t\t\tctx.json([\r\n\t\t\t\t{\r\n\t\t\t\t\tbody: 'This is a body',\r\n\t\t\t\t\tid: 1,\r\n\t\t\t\t\ttitle: 'Title',\r\n\t\t\t\t\tuserId: 1,\r\n\t\t\t\t},\r\n\t\t\t])\r\n\t\t);\r\n\t}),\r\n];\r\n```\r\n\r\nSweet, now we have our handler set up for MSW ðŸš€.\r\n\r\n### Configuration files for Vitest\r\n\r\nMSW sets up a server for us to intercept the requests. But we have to create an instance of the server. Create a `server.js` file in our `mocks` folder:\r\n\r\n```js\r\nimport { setupServer } from 'msw/node';\r\nimport { handlers } from './handlers';\r\n\r\n// Here we import the handler created!\r\nexport const server = setupServer(...handlers);\r\n```\r\n\r\nIn our `vite.config.js` lets add an entry for our setup files in the `test` object:\r\n\r\n```js\r\nsetupFiles: ['./src/setup.js'],\r\n```\r\n\r\nLet's create this `setup.js` file in our `src` directory. This is to correctly reset the server with every test execution:\r\n\r\n```js\r\nimport { server } from './mocks/server';\r\n\r\nbeforeAll(() => server.listen({ onUnhandledRequest: 'error' }));\r\nafterAll(() => server.close());\r\nafterEach(() => server.resetHandlers());\r\n```\r\n\r\nNow we're all set up and ready to test! Let's implement this in our **Vitest** test.\r\n\r\n### Mocking our API request in Vitest\r\n\r\nLet's revamp our test file:\r\n\r\n```js\r\nimport React from 'react';\r\nimport {\r\n\trender,\r\n\tscreen,\r\n\twaitForElementToBeRemoved,\r\n} from '@testing-library/react';\r\nimport userEvent from '@testing-library/user-event';\r\nimport App from './App';\r\n\r\ndescribe('Testing our React application', () => {\r\n\tit('Fetch posts', async () => {\r\n\t\trender(<App />);\r\n\r\n\t\texpect(screen.getByText(/Modern React Testing/i)).toBeDefined();\r\n\r\n\t\tuserEvent.click(screen.getByRole('button', { name: 'Fetch Posts' }));\r\n\r\n\t\tawait waitForElementToBeRemoved(() =>\r\n\t\t\tscreen.queryByLabelText('loading')\r\n\t\t);\r\n\r\n\t\texpect(screen.getByRole('heading', { level: 3 })).toBeDefined();\r\n\t});\r\n});\r\n```\r\n\r\nWe removed the library for `@testing-library/jest-dom` as it is no longer necessary. But, now our test should be passing with green!\r\n\r\n![passing tests](https://cdn.hashnode.com/res/hashnode/image/upload/v1651629090063/KglzuC7bt.png)\r\n\r\nAlso, since our test is running in a node environment we need to polyfill our fetch function in the original `App.jsx`\r\n\r\n```bash\r\nnpm install cross-fetch\r\n```\r\n\r\nJust import it at the very top:\r\n\r\n```js\r\nimport fetch from 'cross-fetch';\r\n```\r\n\r\n### Sidenote\r\n\r\nIf you had been following along my other articles you may have noticed I changed the version of a dependency: `@testing-library/user-event`. I was having an issue firing off the button click.\r\n\r\nI downgraded it to 13.5.0 and called the click event directly from `userEvent`.\r\n\r\nYou can find the entire project in this [repository with the updated list of dependencies](https://github.com/diballesteros/react-testing).\r\n\r\nError message for those googling:\r\n\r\n```bash\r\nError: The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.\r\n```\r\n\r\n### Wrapping it up\r\n\r\nWe now have a powerful tool at our disposal to mock requests as we continue to create unit tests! In the next article, we'll go over how to set up Cypress.io.\r\n\r\nMore content at [Relatable Code](https://relatablecode.com)\r\n\r\n### Let's connect\r\n\r\nIf you liked this feel free to connect with me on [LinkedIn](https://www.linkedin.com/in/relatablecode) or [Twitter](https://twitter.com/relatablecoder)\r\n\r\nCheck out my free developer roadmap and weekly tech industry news in my [newsletter](https://relatablecode.substack.com/).\r\n","recommendations",[29,37,43,48],{"_7":30,"_9":31,"_11":12,"_13":32,"_15":33,"_19":35,"_21":22,"_23":36},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[34],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",4,{"_7":38,"_9":39,"_11":12,"_13":40,"_15":41,"_19":20,"_21":22,"_23":42},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[17,18],3,{"_7":44,"_9":45,"_11":12,"_13":46,"_15":47,"_19":20,"_21":22,"_23":24},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[17,18],{"_7":49,"_9":50,"_11":12,"_13":51,"_15":52,"_19":20,"_21":22,"_23":36},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[17,18]]
