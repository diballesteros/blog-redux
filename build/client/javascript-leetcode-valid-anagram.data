[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_26":27},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_18":19,"_20":21,"_22":23,"_24":25},"slug","javascript-leetcode-valid-anagram","title","JavaScript LeetCode Valid Anagram","date","","description","How to solve the LeetCode problem Valid Anagram using JavaScript. Solved with a hash table.","categories",[17],"dsa","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1652017295987/HA_2pgTM5.png","published",true,"readingTime",3,"content","\r\n#### Prompt\r\n\r\nGiven two stringsÂ `s`Â andÂ `t`, returnÂ `true`Â *if*Â `t`Â *is an anagram of*Â `s`*, and*Â `false`Â *otherwise*.\r\n\r\nAnÂ **Anagram**Â is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\r\n\r\n**Example 1:**\r\n\r\n```text\r\nInput: s = \"anagram\", t = \"nagaram\"\r\nOutput: true\r\n```\r\n\r\n### Analyzing the problem\r\n\r\nLet's this of what the problem is asking. We have to know the contents of the strings we're analyzing. We also have to make sure that we're keeping track of the letters as they should be exactly the same to confirm that it is an **anagram**.\r\n\r\nFollowing that train of thought, we can early return if there is ever a difference in the letters they contain. But what does it mean to have the same letters? Well, essentially it's mapping out the frequency of each letter for the first word we iterate over. When we iterate over the second word we can double-check with what.\r\n\r\nChecking back on the first example provided we can visualize this by counting each letter:\r\n\r\n![JavaScript Leetcode valid anagram](https://cdn.hashnode.com/res/hashnode/image/upload/v1653911095217/WQs1bzQ1i.png)\r\n\r\nLooking at the counts we can use this to validate in place as we iterate over the second word. Let's see how this would look:\r\n\r\n![javascript leetcode](https://cdn.hashnode.com/res/hashnode/image/upload/v1653911387569/kfP3d-hSb.png)\r\n\r\nSo the first time we run into the `n` in the second iteration we subtract it from the count. Anytime we go below `0` then we know the words are **not** valid anagrams.\r\n\r\nCool ðŸ˜Ž, let's get to coding.\r\n\r\n### The solution\r\n\r\nSimilar to our [last problem](https://relatablecode.com/javascript-leetcode-best-time-to-buy-and-sell-stock) we can use a hash table\r\n\r\n```js\r\nvar isAnagram = function (s, t) {\r\n\tif (s.length != t.length) return false;\r\n\tconst hashTable = {};\r\n\r\n\tfor (let i = 0; i < s.length; i++) {\r\n\t\tif (!hashTable[s[i]]) {\r\n\t\t\thashTable[s[i]] = 0;\r\n\t\t}\r\n\t\thashTable[s[i]]++;\r\n\t}\r\n\r\n\tfor (let j = 0; j < t.length; j++) {\r\n\t\tif (!hashTable[t[j]]) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\thashTable[t[j]]--;\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n```\r\n\r\nIn the first iteration, we add the frequency of every letter. If it doesnâ€™t exist we create a 0 value at that point.\r\n\r\n```js\r\nif (!hashTable[s[i]]) {\r\n\thashTable[s[i]] = 0;\r\n}\r\nhashTable[s[i]]++;\r\n```\r\n\r\nOn the second iteration, we subtract all values. If no letter ever exists then weâ€™ll hit the number `0` which means weâ€™ll return a `false`.\r\n\r\n```js\r\nif (!hashTable[t[j]]) {\r\n\treturn false;\r\n}\r\nhashTable[t[j]]--;\r\n```\r\n\r\n### Let's connect\r\n\r\nIf you liked this feel free to connect with me on [LinkedIn](https://www.linkedin.com/in/relatablecode) or [Twitter](https://twitter.com/relatablecoder)\r\n\r\nCheck out my free developer roadmap and weekly tech industry news in my [newsletter](https://relatablecode.substack.com/).\r\n","recommendations",[28,36,44,50],{"_7":29,"_9":30,"_11":12,"_13":31,"_15":32,"_18":34,"_20":21,"_22":35},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[33],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",4,{"_7":37,"_9":38,"_11":12,"_13":39,"_15":40,"_18":43,"_20":21,"_22":23},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[41,42],"testing","react","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png",{"_7":45,"_9":46,"_11":12,"_13":47,"_15":48,"_18":43,"_20":21,"_22":49},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[41,42],5,{"_7":51,"_9":52,"_11":12,"_13":53,"_15":54,"_18":43,"_20":21,"_22":35},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[41,42]]
