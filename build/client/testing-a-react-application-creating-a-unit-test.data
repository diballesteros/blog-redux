[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_27":28},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_19":20,"_21":22,"_23":24,"_25":26},"slug","testing-a-react-application-creating-a-unit-test","title","Testing a React Application Creating a Unit Test","date","","description","Unit tests are essential to ensuring confidence in the code we have written. In the fourth part of this series, I'll be going over how to write our first unit test and the thought process of how I decided what to test.","categories",[17,18],"testing","react","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png","published",true,"readingTime",6,"content","\r\n### Introduction\r\n\r\nUnit tests are essential to ensuring confidence in the code we have written. In the fourth part of this series, I'll be going over how to write our first unit test and the thought process of how I decided what to test.\r\n\r\n[First part](https://relatablecode.com/testing-a-react-application-the-modern-approach/)\r\n\r\n[Second part](https://relatablecode.com/testing-a-react-application-the-setup/)\r\n\r\n[Third part](https://relatablecode.com/testing-a-react-application-what-is-vitest/)\r\n\r\n> A unit test is a testing method for an isolated and individual piece of code, a unit. In the context of React, this more than likely refers to testing our components in isolation and any associated function\r\n\r\nThat's great! But how do we decide exactly what to test? Our tests should only be concerned with the interactions the user expects. Implementation details such as variable names, function names, etc should all be irrelevant in our tests.\r\n\r\n![unit test](https://cdn.hashnode.com/res/hashnode/image/upload/v1651460964006/RZ_YF4dY_.png)\r\n\r\n### Deciding on the Unit Test\r\n\r\nTo give a brief review, we created a very barebones application that fetches some generic JSON and displays them on the page:\r\n\r\n![modern react testing](https://cdn.hashnode.com/res/hashnode/image/upload/v1651461010761/zC7Hk3jwu.png)\r\n\r\nWhat we can reasonably assume the user will care about:\r\n\r\n1. When clicking on the fetch posts button it should list out the posts.\r\n2. When clicking on the clear posts button it should clear the posts.\r\n\r\nWhat we don't care about:\r\n\r\n1. The name of the function calling the fetch request\r\n2. The class names of the elements in the content\r\n\r\n#### Looking at our code\r\n\r\nLet's compare this by looking at our code.\r\n\r\n```js\r\n<section className=\"App-buttons\">\r\n    <button onClick={fetchPosts} type=\"button\">\r\n      Fetch Posts\r\n    </button>\r\n    <button onClick={clearPosts} type=\"button\">\r\n      Clear posts\r\n    </button>\r\n</section>\r\n{loading && <p>Loading...</p>}\r\n{posts.map((post) => (\r\n    <article key={post.id}>\r\n      <h3>{post.title}</h3>\r\n      <p>{post.body}</p>\r\n    </article>\r\n  ))}\r\n</main>\r\n```\r\n\r\nSo to visualize this as if we were the end-user:\r\n\r\n![validate post flow](https://cdn.hashnode.com/res/hashnode/image/upload/v1651461151484/_TP3g_2HH.png)\r\n\r\nWhat's wrong here? Well, we're testing several implementation details such as the content of the response and whether or not the function was executed.\r\n\r\nThese parts should be a black box for our tests.\r\n\r\nSomething better would be:\r\n\r\n![correct unit test flow](https://cdn.hashnode.com/res/hashnode/image/upload/v1651461198905/uvkLzt9lm.png)\r\n\r\nYou may be asking, well doesn't the first option test for more?\r\n\r\nThis is an incorrect way to approach it. Code changes, we tend to refactor. If our tests are constantly breaking when making code changes we add a lot of overhead to development.\r\n\r\nIn the end, what we care about is that the posts are **fetched and displayed**. The details of the function are _irrelevant_.\r\n\r\n### Modifying our App for the first Unit Test\r\n\r\nLet's modify our `vite.config.js` file:\r\n\r\n```js\r\nimport react from '@vitejs/plugin-react';\r\n\r\n// https://vitejs.dev/config/\r\nexport default defineConfig({\r\n\tplugins: [react()],\r\n\ttest: {\r\n\t\tglobals: true,\r\n\t\tenvironment: 'jsdom',\r\n\t},\r\n});\r\n```\r\n\r\n### Writing the Unit Test\r\n\r\nLet's go ahead and create our first test. At the root of our project let's create `App.test.js`\r\n\r\n```js\r\nimport { describe } from 'vitest';\r\n\r\ndescribe('Testing our React application', () => {\r\n\tit('Fetch posts', () => {});\r\n});\r\n```\r\n\r\nBut wait! While creating our test let's watch and see if they're passing or failing. In the terminal run the following command:\r\n\r\n```bash\r\nvitest --watch\r\n```\r\n\r\nThis should generate a failure as we have no assertions in our test:\r\n\r\n![failed test with no assertions](https://cdn.hashnode.com/res/hashnode/image/upload/v1651461390079/Fk_dyHpbK.png)\r\n\r\nNext, in order to render our components, we need the help of another library: [React-testing-library](https://testing-library.com/docs/react-testing-library/intro/).\r\n\r\n> The @testing-library family of packages helps you test UI components in a user-centric way.\r\n\r\n```bash\r\nnpm install @testing-library/react @testing-library/jest-dom @testing-library/user-events --save-dev\r\n```\r\n\r\nFirst, let's just check we can correctly render and pass a test:\r\n\r\n```js\r\nimport React from 'react';\r\nimport { describe, expect, it } from 'vitest';\r\nimport { render, screen } from '@testing-library/react';\r\nimport '@testing-library/jest-dom';\r\nimport App from './App';\r\n\r\ndescribe('Testing our React application', () => {\r\n\tit('Fetch posts', async () => {\r\n\t\trender(<App />);\r\n\r\n\t\texpect(screen.getByText(/Modern React Testing/i)).toBeInTheDocument();\r\n\t});\r\n});\r\n```\r\n\r\nHere we just render our app and check for the title of our heading. Expect in this case is our assertion that decides if we pass a test or not.\r\n\r\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651461506563/0mI3pyql6.png)\r\n\r\n### Unit Test for fetching\r\n\r\nBut this isn't really relevant to actual testing. So let's try working with our button and post-fetching functionalities.\r\n\r\n```js\r\nimport React from 'react';\r\nimport { describe } from 'vitest';\r\nimport { render, screen } from '@testing-library/react';\r\nimport userEvent from '@testing-library/user-event';\r\nimport '@testing-library/jest-dom';\r\nimport App from './App';\r\n\r\ndescribe('Testing our React application', () => {\r\n\tit('Fetch posts', () => {\r\n\t\tconst user = userEvent.setup();\r\n\r\n\t\trender(<App />);\r\n\r\n\t\texpect(screen.getByText(/Modern React Testing/i)).toBeInTheDocument();\r\n\t});\r\n});\r\n```\r\n\r\n`userEvent` in this case lets us follow a core principle we laid out at the very beginning: Make tests that can most closely resemble how the user interacts with the application.\r\n\r\nFor example, inside of our userEvent object, we have access to the click function! And with this click function, we can send in an argument to look for our button.\r\n\r\n```js\r\nuserEvent.click(screen.getByRole('button', { name: 'Fetch Posts' }));\r\n```\r\n\r\nLet's explain this with a diagram:\r\n\r\n![explaining a userEvent click](https://cdn.hashnode.com/res/hashnode/image/upload/v1651461598950/AEKziXpL-.png)\r\n\r\nA whole lot of utilities to click the button in our unit test. However, the function invoked by clicking the button is asynchronous. So let's make our test asynchronous and wait for the posts to be fetched.\r\n\r\nLater on, we'll mock this request to test for more possibilities.\r\n\r\n```js\r\nimport { describe } from 'vitest';\r\nimport { render, screen } from '@testing-library/react';\r\nimport { userEvent } from '@testing-library/user-event';\r\nimport App from './App';\r\n\r\ndescribe('Testing our React application', async () => {\r\n    it('Fetch posts', () => {\r\n      render(<App />);\r\n      userEvent.click(screen.getByRole('button', { name:'Fetch Posts'}));\r\n\r\n      await waitForElementToBeRemoved(() => screen.queryByLabelText('Loading...')\r\n);\r\n\r\n      expect(screen.getByRole('heading', { level: 3 })).toBeDefined();\r\n    });\r\n});\r\n```\r\n\r\nPerfect. Yet again we're using the screen functionality and just waiting for the Loading text to disappear.\r\n\r\n**BUT**, this will give us an error...but why? Well, we're not stubbing or mocking the fetch service that's called when clicking the button. How can we solve that?\r\n\r\n### Wrapping it up\r\n\r\nIn the next article, I'll go over how to use MSW to mock requests that are launched from the tests. We'll go over the setup and integrate it with this test!\r\n\r\nMore content at [Relatable Code](https://relatablecode.com)\r\n\r\n### Let's connect\r\n\r\nIf you liked this feel free to connect with me on [LinkedIn](https://www.linkedin.com/in/relatablecode) or [Twitter](https://twitter.com/relatablecoder)\r\n\r\nCheck out my free developer roadmap and weekly tech industry news in my [newsletter](https://relatablecode.substack.com/).\r\n","recommendations",[29,37,43,49],{"_7":30,"_9":31,"_11":12,"_13":32,"_15":33,"_19":35,"_21":22,"_23":36},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[34],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",4,{"_7":38,"_9":39,"_11":12,"_13":40,"_15":41,"_19":20,"_21":22,"_23":42},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[17,18],3,{"_7":44,"_9":45,"_11":12,"_13":46,"_15":47,"_19":20,"_21":22,"_23":48},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[17,18],5,{"_7":50,"_9":51,"_11":12,"_13":52,"_15":53,"_19":20,"_21":22,"_23":36},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[17,18]]
