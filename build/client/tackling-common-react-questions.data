[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_26":27},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_18":19,"_20":21,"_22":23,"_24":25},"slug","tackling-common-react-questions","title","Tackling Common React Interview Questions","date","","description","In this article I go over some common React interview questions understanding how to answer them and why these are the appropriate answers.","categories",[17],"react","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1685921736070/f448be0b-a7bc-4622-90cd-1aa1fd7dc92c.png","published",true,"readingTime",7,"content","\r\n## Introduction\r\n\r\nReact has been a part of the front-end developer ecosystem for over ten years now! That's a long time. As a result, it is quite common to see React listed as a requirement for jobs. Let's take a look at some common React Interview Questions\r\n\r\n## What are the main features of React?\r\n\r\n1. JSX - This is a syntax extension that lets you write HTML-like markup inside a JavaScript file. JSX is not unique to React but most React projects use it. But why use it? It enables us to co-locate our rendering logic with our markup.\r\n\r\n    Three rules of JSX: Return a single root element, close all the tags, and camelCase most things.\r\n\r\n2. Components - These are the building blocks of React. As mentioned previously these are built using JSX. This is what lets us build a modular front end.\r\n3. Virtual DOM - Behind the scenes, this is how React does its magic. React keeps a lightweight representation of the real DOM in memory, it then checks changes in the state and only updates what is necessary.\r\n4. One-way data-binding - React heavily encourages a unidirectional flow of data from top to bottom. This is why we commonly nest child components within parent components and transfer the data by passing props.\r\n5. High performance - React only updates the components (or re-renders) that have changed rather than updating all components on every change.\r\n\r\n## How do web browsers interpret JSX?\r\n\r\nAlthough JSX is JavaScript, browsers are unable to understand JSX. We use transpilers such as Babel or SWC to transform JSX into browser-compatible JavaScript.\r\n\r\n## What are synthetic events in React?\r\n\r\nTypically browsers have native events that we interpret on the front end to handle a user's action, for example, clicking a button or typing in an input. React, to standardize this behavior across browsers, has implemented synthetic events which combine all these events into a singular API.\r\n\r\n```javascript\r\nconst handlepreventDefault = (e) => {\r\n\te.preventDefault();\r\n\tconsole.log('clicked on preventDefault');\r\n};\r\n```\r\n\r\n## What is state in React?\r\n\r\nThe state is a unique JavaScript variable for React that will trigger a re-render in the UI when it is changed or updated. This is necessary to use over a typical JavaScript variable because we want to keep our changes in the logic in sync with changes in the UI.\r\n\r\n```javascript\r\nconst [index, setIndex] = useState(0);\r\n```\r\n\r\n## What is state hoisting?\r\n\r\nState hoisting, or in other words \"Lifting state up\" is when we move the stateful logic of a component to its parent component. The purpose of this is to make sure that two children's components can act on the same data.\r\n\r\nBefore we mentioned that data should obey the principle of one-way data-binding. So our data should only flow one way. State hoisting allows us to continue this principle by making sure our data is used in the places it is needed to be.\r\n\r\n## What is the purpose of a function as a Child?\r\n\r\nThis is a React pattern that lets you pass a render function for the `children` prop. For example:\r\n\r\n```javascript\r\n<Foo>{(name) => <div>`hello from ${name}`</div>}</Foo>\r\n```\r\n\r\nThen the `Foo` component would be able to use the function by calling `children`:\r\n\r\n```javascript\r\nconst Foo = ({ children }) => {\r\n\treturn children('foo');\r\n};\r\n```\r\n\r\nHere we can use the children function, and send in the `name` parameter to be invoked in the parent component's logic.\r\n\r\n## Explain the differences between a Presentational Component and a Container Component\r\n\r\nPresentational components are concerned with the UI while the container component is more so concerned with how things work (IE the stateful logic).\r\n\r\nTake into consideration that Dan Abramov, one of the creators of React doesn't necessarily believe this to be necessary anymore depending on the rest of the codebase, especially with hooks. Take a look at his original [article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#:~:text=While%20container%20components%20tend%20to,as%20classes%20and%20as%20functions.).\r\n\r\n## Why do we need keys for React Lists?\r\n\r\nFor React to differentiate between different elements in a list and correctly order them we give every element in a list a unique identifier, or a `key`.\r\n\r\n```javascript\r\n<ul>\r\n\t{artists.map((artist) => (\r\n\t\t<li key={artist.id}>{artist.name}</li>\r\n\t))}\r\n</ul>\r\n```\r\n\r\n## Explain closures in React\r\n\r\nTo quickly summarize, closures are about having access to variables in the parent scope even after the parent function finishes its execution. React is JavaScript, so naturally we have access to this same principle.\r\n\r\nWhenever you've used a `useState` hook you've already used closures in react:\r\n\r\n```javascript\r\nimport React, { useState } from 'react';\r\nfunction Counter() {\r\n\tconst [count, setCount] = useState(0);\r\n\r\n\tconst handleClick = () => {\r\n\t\tsetCount(count + 1);\r\n\t};\r\n\treturn <button onClick={handleClick}>You clicked me {count} times</button>;\r\n}\r\n```\r\n\r\nThe `handleClick` function has access to the `count` even after finishing the execution of the `Counter` component function. Higher-order components behave under a similar paradigm.\r\n\r\n## What is the purpose of fragments?\r\n\r\nA `<Fragment />` which also includes the `<> ... </>` syntax. This lets you group elements without a wrapper node. As a small aside if you include the word `Fragment` inside the syntax, you can add a `key` as you would in a list.\r\n\r\n## Explain the core hooks in the React ecosystem\r\n\r\n1. `useState` - lets you add a state variable to your component\r\n2. `useEffect` - lets you synchronize a component with an external system and/or add side effects to a component\r\n3. `useContext` - lets you read and subscribe to a context from your component. Context in this case refers to information available to any component in the tree below it.\r\n4. `useRef` - lets you reference a value that's not needed for rendering.\r\n5. `useMemo` - lets you cache the result of a calculation between renders. Take note this is good for calculating derived values based on a dependency array.\r\n6. `useCallback` - lets you cache a function definition between re-renders. Similar to `useMemo` it is created based on a dependency array.\r\n\r\n## How do you create a custom hook?\r\n\r\nYou create a custom hook whenever you want to share logic between two functional components. It's important to keep in mind that two hooks don't normally share the same state they just share the same logic.\r\n\r\nFor example, directly from the React docs, you may have a hook that handles the state inside a form input:\r\n\r\n```javascript\r\nexport function useFormInput(initialValue) {\r\n\tconst [value, setValue] = useState(initialValue);\r\n\r\n\tfunction handleChange(e) {\r\n\t\tsetValue(e.target.value);\r\n\t}\r\n\r\n\tconst inputProps = {\r\n\t\tvalue: value,\r\n\t\tonChange: handleChange,\r\n\t};\r\n\r\n\treturn inputProps;\r\n}\r\n```\r\n\r\nWithin the hook, we notice a few rules we should follow. We can only call hooks within other hooks or functional components and the hooks should be at the top of the file and **always** rendered in the same order.\r\n\r\nThis can then be called within our component:\r\n\r\n```javascript\r\nfunction Form() {\r\n  const firstNameProps = useFormInput('Mary');\r\n  const lastNameProps = useFormInput('Poppins');\r\n  // ...\r\n```\r\n\r\nAlso, take notice that we can share stateful logic without sharing the state.\r\n\r\n## What is the difference between class and functional components?\r\n\r\nReact class components rely more on the ES6 syntax of classes.\r\n\r\n```javascript\r\nclass Welcome extends React.Component {\r\n\trender() {\r\n\t\treturn <h1>Hello, {this.props.name}</h1>;\r\n\t}\r\n}\r\n```\r\n\r\nPreviously only class components could handle stateful logic and lifecycle methods. This is no longer the case with the introduction of hooks. Functional components can colocate state and lifecycle methods with `useState` and `useEffect` respectively.\r\n\r\nAlso, something to keep in mind, the creators of React are aligned with promoting and moving forward with hooks and functional components.\r\n\r\n## What is a higher-order component (HOC)?\r\n\r\nA higher-order component is another way of sharing code. Essentially, it takes a component and wraps it with some added functionality, then it returns itself.\r\n\r\nSo for example, if you have an API call that you need to access in several parts of the application, you could create a higher-order component that does this API call and use this wrap other components.\r\n\r\nTypically they start with the keyword `with`\r\n\r\n### Wrapping it up\r\n\r\nObviously, there are several other questions about the React ecosystem that could pop up but I think this is a good foundation. Leave a comment down below with any questions you've received before.\r\n\r\n### Let's Connect\r\n\r\nIf you liked this feel free to connect with me on [LinkedIn](https://www.linkedin.com/in/relatablecode) or [Twitter](https://twitter.com/relatablecoder)\r\n","recommendations",[28,36,44,50],{"_7":29,"_9":30,"_11":12,"_13":31,"_15":32,"_18":34,"_20":21,"_22":35},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[33],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",4,{"_7":37,"_9":38,"_11":12,"_13":39,"_15":40,"_18":42,"_20":21,"_22":43},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[41,17],"testing","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png",3,{"_7":45,"_9":46,"_11":12,"_13":47,"_15":48,"_18":42,"_20":21,"_22":49},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[41,17],5,{"_7":51,"_9":52,"_11":12,"_13":53,"_15":54,"_18":42,"_20":21,"_22":35},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[41,17]]
