[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_26":27},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_18":19,"_20":21,"_22":23,"_24":25},"slug","how-to-easily-trigger-react-spring-animation-when-in-view","title","How to easily trigger react-spring animation when in view","date","","description","How to trigger a react-spring animation when in view using React hooks. Using Intersection Observer and useSpring create a seamless animation when on screen","categories",[17],"react","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1651104429605/NhNnm0FSM.png","published",true,"readingTime",4,"content","\r\n### Introduction\r\n\r\n[react-spring](https://react-spring.io/) is a library to easily create and integrate animations in a React app. A possible use-case of the library is triggering an animation only when a particular ref or component is in view.\r\n\r\nIn this tutorial, I’ll cover how to set up react-spring and the hooks necessary!\r\n\r\nThis guide assumes familiarity with React and react-spring and the fundamentals of React Hooks.\r\n\r\n### Requirements\r\n\r\nFor the sake of the example let’s say we have a webpage that is split into two sections. Both sections take up the entire viewport. When scrolling down to the second page let’s have a header fly in from the right.\r\n\r\n### Getting started\r\n\r\nFirst, let’s set up the page with just the visual portion:\r\n\r\n```js\r\n<div className=\"App\">\r\n\t<div style={{ backgroundColor: 'grey' }}>\r\n\t\t<h1>This is my first page</h1>\r\n\t</div>\r\n\t<div style={{ backgroundColor: 'white' }}>\r\n\t\t<h2>This should come flying in</h2>\r\n\t</div>\r\n</div>\r\n```\r\n\r\nI’ve added some styles to better differentiate between both sections.\r\n\r\nNow with the styles out of the way let’s set up the react-spring hook to make it fly in. We need to use useSpring to set up the animation and change the h2 element to an animated h2 element.\r\n\r\n```js\r\nconst headerStyle = useSpring({\r\n\tconfig: { duration: 500 },\r\n\tfrom: { opacity: 0, left: '-500px' },\r\n\tto: {\r\n\t\topacity: 1,\r\n\t\tleft: '-500px',\r\n\t},\r\n});\r\n\r\nreturn (\r\n\t<div className=\"App\">\r\n\t\t<div style={{ backgroundColor: 'grey' }}>\r\n\t\t\t<h1>This is my first page</h1>\r\n\t\t</div>\r\n\t\t<div style={{ backgroundColor: 'white' }}>\r\n\t\t\t<animated.h2 style={headerStyle}>\r\n\t\t\t\tThis should come flying in\r\n\t\t\t</animated.h2>\r\n\t\t</div>\r\n\t</div>\r\n);\r\n```\r\n\r\nPerfect. But wait our hook is missing some validations in order to transition between two styles. Luckily, modern browsers offer access to the Intersection Observer API. Without getting into the nitty-gritty, this API lets us detect elements that are visible.\r\n\r\n### Intersection Observer\r\n\r\nLet’s go ahead and create the hook we’re going to use:\r\n\r\n```js\r\nfunction useIntersectionObserver(\r\n\telementRef,\r\n\t{ threshold = 0, root = null, rootMargin = '0%', freezeOnceVisible = false }\r\n) {\r\n\tconst [entry, setEntry] = useState();\r\n\r\n\tconst frozen = entry?.isIntersecting && freezeOnceVisible;\r\n\r\n\tconst updateEntry = ([entry]) => {\r\n\t\tsetEntry(entry);\r\n\t};\r\n\r\n\tuseEffect(() => {\r\n\t\tconst node = elementRef?.current;\r\n\t\tconst hasIOSupport = !!window.IntersectionObserver;\r\n\r\n\t\tif (!hasIOSupport || frozen || !node) return;\r\n\r\n\t\tconst observerParams = { threshold, root, rootMargin };\r\n\t\tconst observer = new IntersectionObserver(updateEntry, observerParams);\r\n\r\n\t\tobserver.observe(node);\r\n\r\n\t\treturn () => observer.disconnect();\r\n\t}, [elementRef, threshold, root, rootMargin, frozen]);\r\n\r\n\treturn entry;\r\n}\r\n```\r\n\r\nAlright, let’s example how this hook works. Essentially it receives a ref, the node stored in the ref is then set to be observed by the IntersectionObserver. A callback is passed to the observer so it is called when in view.\r\n\r\nA local state is then set and we return this same entry. An additional parameter is available to freeze the trigger so it isn’t executed multiple times.\r\n\r\n### Hooking it up\r\n\r\nNext, let’s create the ref and hook it up to the new hook we just created:\r\n\r\n```js\r\n  const triggerRef = useRef();\r\n  const dataRef = useIntersectionObserver(triggerRef, {\r\n    freezeOnceVisible: true\r\n  });\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div style={{ backgroundColor: \"grey\" }}>\r\n        <h1>This is my first page</h1>\r\n      </div>\r\n      <div style={{ backgroundColor: \"white\" }}>\r\n        <animated.h2 style={headerStyle}>\r\n          This should come flying in\r\n        </animated.h2>\r\n        <div ref={triggerRef} />\r\n      </div>\r\n    </div>\r\n```\r\n\r\nWe set up a trigger ref right below the header and we’re sending this same ref to useIntersectionObserver.\r\n\r\nIf we go ahead and console.log() the dataRef we should see it getting populated if we scroll down.\r\n\r\nInside the object there is a particular property that interests us:\r\n\r\n![Values of entry of IntersectionObserver](https://cdn.hashnode.com/res/hashnode/image/upload/v1649284965533/-_BvEv6jp.png)\r\n\r\nisIntersecting is exactly what it says. When it’s visible and intersecting with the DOM/viewport it will change over to true. Let’s go ahead and set up the useSpring to validate this property.\r\n\r\n```js\r\nconst headerStyle = useSpring({\r\n\tconfig: { duration: 500 },\r\n\tfrom: { opacity: 0, left: '-500px' },\r\n\tto: {\r\n\t\topacity: dataRef?.isIntersecting ? 1 : 0,\r\n\t\tleft: dataRef?.isIntersecting ? '0px' : '-500px',\r\n\t},\r\n});\r\n```\r\n\r\nAnd that’s it! Here’s the working example:\r\n\r\nhttps://codesandbox.io/embed/trigger-react-spring-in-view-c5e76?fontsize=14&hidenavigation=1&theme=dark\r\n","recommendations",[28,35,43,49],{"_7":29,"_9":30,"_11":12,"_13":31,"_15":32,"_18":34,"_20":21,"_22":23},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[33],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",{"_7":36,"_9":37,"_11":12,"_13":38,"_15":39,"_18":41,"_20":21,"_22":42},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[40,17],"testing","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png",3,{"_7":44,"_9":45,"_11":12,"_13":46,"_15":47,"_18":41,"_20":21,"_22":48},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[40,17],5,{"_7":50,"_9":51,"_11":12,"_13":52,"_15":53,"_18":41,"_20":21,"_22":23},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[40,17]]
