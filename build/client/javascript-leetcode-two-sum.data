[{"_1":2},"routes/$slug",{"_3":4},"data",{"_5":6,"_26":27},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_18":19,"_20":21,"_22":23,"_24":25},"slug","javascript-leetcode-two-sum","title","JavaScript LeetCode Two Sum","date","","description","How to solve Two sum LeetCode problem using JavaScript. I go over the brute force solution and the hash table one-pass solution.","categories",[17],"dsa","coverImage","https://cdn.hashnode.com/res/hashnode/image/upload/v1652017295987/HA_2pgTM5.png","published",true,"readingTime",5,"content","\r\n### Introduction\r\n\r\nLeetCode. An unfortunate truth of developer life is that for some job interviews it is necessary to learn Data structure and algorithms (DSA) in a specific way. A way in which you're expected to code up a solution to a DSA problem where you would otherwise google it.\r\n\r\nI say **unfortunate** because in most cases it is unnecessary to know them to the degree required for the technical interviews and hardly reflects actual job capability.\r\n\r\nBut I digress, LeetCode is a website that compiles tons of different DSA problems. I'll be going through several LeetCode problems over the next month, explaining and solving them, to help others out. And also it helps me to re-write the solution. ðŸ˜Ž\r\n\r\n### Prompt\r\n\r\n> Given an array of integersÂ `nums`Â and an integerÂ `target`, returnÂ indices of the two numbers such that they add up toÂ `target`. You may assume that each input would haveÂ ***exactly*Â one solution**, and you may not use theÂ *same*Â element twice. You can return the answer in any order.\r\n\r\nExample 1:\r\n\r\n```text\r\nInput: nums = [2,7,11,15], target = 9\r\nOutput: [0,1]\r\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\r\n```\r\n\r\n### Thinking it through\r\n\r\nThis is the first LeetCode problem and is quite an easy one. What first comes to mind is just iterating over the array twice and finding the necessary sum. This will 100% give us the solution.\r\n\r\nHowever, as many of you may know about these types of questions. Usually, it is not enough to be correct. For DSA problems you want to be as **efficient** as possible.\r\n\r\n![aron-visuals-BXOXnQ26B7o-unsplash.jpg](https://cdn.hashnode.com/res/hashnode/image/upload/v1652014910383/fujVS3HuP.jpg)\r\n_Photo by Aron Visuals on Unsplash_\r\n\r\nSo for example our first solution would be something along these lines:\r\n\r\n![brute force](https://cdn.hashnode.com/res/hashnode/image/upload/v1652015420274/fSkf9b4o1.png)\r\n\r\nWhere `i` is the value of our first iteration and `j` is the value of our second iteration. Once added up we get `9` which is the solution we need.\r\n\r\n### First solution\r\n\r\nI mainly use JavaScript so the solution would look something like this:\r\n\r\n```javascript\r\nconst twoSum(nums, target) {\r\n    for(let i = 0;  i < nums.length; i++) {\r\n        for (let j = 0; j < nums.length; j++) {\r\n            if(j === i) continue;\r\n            if((nums[i] + nums[j]) === target) return [i, j];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`nums` is the array of numbers and `target` is the desired solution. I iterate over both arrays and check if the sum is the necessary value. However, as stated in the prompt, we should not use the same element twice.\r\n\r\nSo we can check if the iterations are on the same element and skip:\r\n\r\n```javascript\r\nif(j === i) continue;\r\n```\r\n\r\nHowever, as I mentioned before this is very unoptimized.\r\n\r\n### Second solution\r\n\r\nA much better solution would be searching for the target based on the **current** number. What does that mean?\r\n\r\nFor example, when you first start iterating over the array you know the exact number youâ€™re looking for. The number you're looking for is the **result of the subtraction of the target and the current iterated value.**\r\n\r\nLet's take our first array as an example.\r\n\r\n![first iteration](https://cdn.hashnode.com/res/hashnode/image/upload/v1652015969006/18sS3y3d5.png)\r\n\r\nWhen we're on the first element `2` we know that we need to find as `9` minus `2` is 7. But, we need a way to quickly re-access data of the array.\r\n\r\nIntroducing a Hash Table.\r\n\r\n#### Hash Table\r\n\r\nA [hash table](https://en.wikipedia.org/wiki/Hash_table#:~:text=In%20computing%2C%20a%20hash%20table,desired%20value%20can%20be%20found.) is a data structure that maps key to values. This is perfect for our use-case because we just want to map our `number` to our `index`.\r\n\r\nBut how do we create this hash table?\r\n\r\n[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) is a Javascript built-in object. The only thing you need to know is that it holds key-value pairs and has an API to quickly check the content:\r\n\r\n`.set` for setting the key and value pair\r\n\r\n`.get` for getting the value based on the key\r\n\r\n`.has` for checking if it has the key\r\n\r\n### Second Solution\r\n\r\n```javascript\r\nconst hashTable = new Map();\r\n\r\nfor (let i = 0; i < nums.length; i++) {\r\n\tconst num = nums[i];\r\n\tconst substractionWeWant = target - num;\r\n\r\n\tif (hashTable.has(substractionWeWant)) {\r\n\t\treturn [i, hashTable.get(substractionWeWant)];\r\n\t} else {\r\n\t\thashTable.set(num, i);\r\n\t}\r\n}\r\n```\r\n\r\nWe now have a simplified way to check for previous values. Going back to the code we first do a single iteration of the loop. By subtracting the `target` value from the current index value `num` we can check if the remainder already exists. If it doesnâ€™t we just add the value we just tried to the map and move on.\r\n\r\nSo to reiterate\r\n\r\n1. We loop over the array\r\n2. We check if our current map of values has the subtraction of our `target` and current value we are iterating over. If it does we return both the index of the current value and the index of the value in our map\r\n3. If we donâ€™t find a match we add it to our map and move on\r\n\r\nFirst solution:\r\n\r\n![246ms first solution](https://cdn.hashnode.com/res/hashnode/image/upload/v1652016859386/pnWGBQQbk.png)\r\n\r\nSecond solution:\r\n\r\n![67ms second solution](https://cdn.hashnode.com/res/hashnode/image/upload/v1652016877925/81s2igcnV.png)\r\n\r\n### Wrapping it up\r\n\r\nIf you want to keep up with this series feel free to follow me on here or any of my social media below!\r\n\r\nMore content at [Relatable Code](https://relatablecode.com)\r\n\r\n### Let's connect\r\n\r\nIf you liked this feel free to connect with me on [LinkedIn](https://www.linkedin.com/in/relatablecode) or [Twitter](https://twitter.com/relatablecoder)\r\n\r\nCheck out my free developer roadmap and weekly tech industry news in my [newsletter](https://relatablecode.substack.com/).\r\n","recommendations",[28,36,45,50],{"_7":29,"_9":30,"_11":12,"_13":31,"_15":32,"_18":34,"_20":21,"_22":35},"what-is-imposter-syndrome-and-how-i-deal-with-it","What is imposter syndrome? And how I deal with it","Imposter syndrome is a common feeling to have as a software developer even if you've been doing it for years. I go over my personal experiences with it.",[33],"devlog","https://cdn.hashnode.com/res/hashnode/image/upload/v1651102112425/KKsbnfbCK.png",4,{"_7":37,"_9":38,"_11":12,"_13":39,"_15":40,"_18":43,"_20":21,"_22":44},"testing-a-reaction-application-updating-to-cypress-version-10","Testing a Reaction Application updating to Cypress Version 10","Testing a modern React application. In this part of the series, we go over how to update Cypress to version 10.",[41,42],"testing","react","https://cdn.hashnode.com/res/hashnode/image/upload/v1651098470347/9coA_akWr.png",3,{"_7":46,"_9":47,"_11":12,"_13":48,"_15":49,"_18":43,"_20":21,"_22":23},"testing-a-react-application-working-with-codecov","Testing a React Application Working with Codecov","How to test a React web application and upload the test code coverage results to Codecov.",[41,42],{"_7":51,"_9":52,"_11":12,"_13":53,"_15":54,"_18":43,"_20":21,"_22":35},"testing-a-react-application-what-is-vitest","Testing a React Application What is Vitest?","The third part of a series of articles on how to test a React Application. I go over how Vitest and its syntax work in the simplest terms.",[41,42]]
